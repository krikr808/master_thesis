\chapter{Improvements}

There are a lot of improvements of the method that was implemented in \thisprojectwork that can be performed, many of them which are necessary  to make the method be practically useful in a real-time flight simulator.

\section{Required improvements}

In this section, some of the improvements that are required to make the method practically useful are presented.

\subsection{Adaptive Mesh Refinement}

The \LOD needs to be adapted to the \idxs{camera}{placement} and the \FOV/\idxs{viewing}{frustum} as well as the water depth in order to greatly reduce the number of cells used by the \FVM in the simulation, in order to only use the minimum amount of cells that are actually needed. This is referred to as \AMR.

Without \AMR it would be impossible to simulate larges bodies of water and fine surface details real-time in the same scene, as these would require heaps of orders of magnitude more cells to still be able to simulate waves with the same short \wavelength as with \AMR.

\subsubsection{No simulation of air} In \thisprojectwork, not just the water was simulated, but also the air, which meant that the simulation domain needed to have a boundary in the air. This introduced the additional problem of choosing where the boundary should be located, and what boundary conditions it should have. Additionally, this meant extra computational work since more cells had to be simulated which reduced the simulation speed significantly, and it introduced the phenomenon that velocities could suddenly go to infinity, which froze the simulation.

A better solution would be to exclude the air region and treat that as vacuum, and move the boundary to the interface between the water and the vacuum/air region.

\subsection{Unconditionally stable flows}

In order to make a \FVM simulation become practically useful for \idxsp{real-time}{simulation}{s}, it is required that the flow is \idxse{unconditionally stable}{flow}{unconditionally stable}\index{stable flow!unconditionally|see{unconditionally stable flows}}. This implies that it is necessary that arbitrarily large \timesteps can be taken without making the simulation unstable.

When it comes to physical quantities with a non-damped \oscillating behavior, simulations which use any kind of normal, \idxs{explicit}{time-stepping}\index{stepping!in time|see{time-stepping}} often tend to make them become unstable and create a \idxs{numerical}{explosion}.

In \thisprojectwork, a kind of \idxs{leapfrog}{integration} has been used to model the time evolution of the velocity and the pressure, but even \idxs{leapfrog}{integration} has to obey the \CFL condition, and it becomes numerically unstable when the \period of the oscillations becomes too small in relation to the \timestep. To solve this problem, many methods \approximate the fluid or the fluids as \incompressible, whilst other use \idxse{implicit}{Euler integration}{backwards (or implicit) Euler integration}\index{integration!implicit Euler|see{implicit Euler integration}} (see 
\secref{sec:pressure_calculation} for a more detailed discussion about this).

On the other hand, when it comes to advection, many advection schemes tend to become numerically unstable when the \idxs{Courant}{number} $C$ becomes too large (this normally means larger than one). Whilst most \idxsp{explicit}{Runge--Kutta method}{s}\index{method!explicit Runge--Kutta|see{explicit Runge--Kutta method}} for advecting any form of field tend to damp high frequent features in the field for $C < 1$, they do the opposite for $C > 1$ and instead enhance the high frequent features and become unstable. If a \idxs{backwards}{Runge--Kutta method}\index{method!backwards Runge--Kutta|see{backwards Runge--Kutta method}} is used instead, in an attempt to remedy this instability, the behaviors will be the reversed and high frequent features will be damped for $C > 1$, hence making the simulation stable in those regions, whilst they will be enhanced for $C < 1$, hence still making the simulation unstable.

A remedy for this dilemma is to use semi-Lagrangian advection, which works by calculating which locations will end up on the \idxsp{discretization}{point}{s} in the end of the time step, and assigning interpolations of the field in those locations to the discretization points in the end of the time step.

All of these instability issues can be remedied \citep{Stam1999}.

\subsection{Rendering}

In \thisprojectwork, the water surface is not rendered. To render the surface properly, an isosurface needs to be extracted from the \idxs{phase fraction}{data}.

\subsubsection{Marching Cubes}

In order to find where the \idxs{water}{surface} is located, the \idxs{marching}{cubes} \idxe{algorithm!marching cubes|see{marching cubes}}{algorithm} can be used. Marching cubes is an algorithm for finding \isosurfaces from a \idxs{scalar}{field}, and works by looping over a set of adjacent cubes tiled closely together which just covers the domain that is about to be rendered. For each cube, the algorithm looks at the value of the scalar field in all eight of the cube's corners. If the field values in the corners all lie at the same side of the value $c$ that the isosurface represents, it figures that the surface doesn't cross through that cube, otherwise it does and the algorithm adapts a surface consisting of a finite number of polygons through the cube depending on what the field values in the corners are.

In \thisprojectwork, the scalar field that tells where the surface is located is the \idxs{phase fraction} {field}, $\alpha$, and since $\alpha$ crosses from 0 to 1 over the \interface, the isosurface can really bee chosen for any level $0 < c < 1$ and the marching cubes algorithm will produce an isosurface lying within the interface, although it probably makes more sense to choose $c = 0.5$ which lies in the middle of the interval and makes the isosurface generation symmetric in that sense. One problem though is that the $\alpha$ field isn't discretized in the cell corners, but in the cell centers. This can be remedied by defining a new set of cubes which have their corners in the centers of the cells. This will become a bit problematic in \idxsp{LOD}{transition}{s}, for which the cubes if created in this way will stretch over two different LODs and thus not have a very well defined size. Another possible solution is to interpolate the $\alpha$ field to the cell corners so that the cells can be used directly as the cubes needed by the algorithm.

If the \VOF method for tracing the surface would be switched to using the \LS method instead, a signed distance function, $\phi$, would be used instead of $\alpha$, and $c = 0$ would define where the surface is located. The discretization points for $\phi$ would be in the cell corners, so there would be no need for defining a new set of cubes in order for the marching cubes algorithm to work. However, the marching cubes algorithm would have apparent problems to generate the surface in \idxsp{LOD}{transition}{s}, since, in it's original form, requires that all cubes are of the same size, otherwise glitches may occur.

The problem of generating the isosurface with the marching cubes algorithm when the domain that is to be rendered contains LOD transitions is well known, and remedies exist. For example, the one in \textit{\href{http://www.terathon.com/lengyel/Lengyel-VoxelTerrain.pdf}{Voxel-Based Terrain for Real-Time Virtual Simulations} + \href{http://www.terathon.com/voxels/}{The Transvoxel$^{\textbf{TM}}$ Algorithm}} (Lengyel, Eric. "Voxel-Based Terrain for Real-Time Virtual Simulations". PhD diss., University of California at Davis, 2010.) \citep{temp} remedies this, but only for cases where the cubes used by the algorithm are modeled as an \octree.

\subsection{Parallelization}

In order to obtain a simulation speed-up that is almost certainly needed, it can be processed on multiple \CPUs simultaneously, as well as on the \GPU (if the \octree traversal is implemented to run without recursion, since \GPUs generally don't have any stack which means that they can't do recursion). This is generally referred to as \parallelization. For parallelization to be possible, the \idxs{simulation}{domain} first has to be \partitioned, so that a small part of the domain can be processed on each core and on each \idxs{GPU}{process}.

Since the process that takes the longest time to run will decide the speed of the simulation, the size of the partitions should be roughly the same. Besides, access to data that is located outside of the partition takes extra long time, so it is desired that the number of neighbors cells for each partition that lies outside of the partition itself is kept low, which is somewhat similar to the problem of minimizing the area between the partitions. For a structured grid, the partitioning can be effectively achieved by cutting the simulation domain into square or cubic pieces. However, for an \idxs{unstructured}{grid} like an \octree, the partitioning is more difficult, but still possible.

For octrees, there are some very convenient algorithms that can be used which make use of \idxsp{space-filling}{curve}{s} and which are fast, easy to implement and still produce very acceptable results (see e.g. \textit{\href{http://j.teresco.org/research/publications/octpart02/octpart02.pdf}{Dynamic Octree Load Balancing Using Space-Filling Curves}} \citep{temp} and \textit{\href{http://downloads.isrn.com/journals/appmath/2012/246491.pdf}{Parallel Adaptive Mesh Refinement Combined with Additive Multigrid for the Efficient Solution of the Poisson Equation}} \citep{temp}). Another kind of partitioning is also performed in \textit{\href{http://gfs.sourceforge.net/papers/agbaglah2011.pdf}{Parallel simulation of multiphase flows using octree adaptivity and the volume-of-fluid method}} \citep{temp} which uses \idxs{domain}{decomposition}.

\subsection{Fluid--Structure Interaction}

In \thisprojectwork, no interaction between ships and the surface waves was ever modeled, in other words, no \FSI was modeled. Modeling and simulating \FSI is necessary in order to make large waves affect ships so that they start to rock forth and back, as well as in order for ships to give rise to two \idxsp{wake}{line}{s} as they \sail on the water.
    
Some of the methods for modeling \FSI includes the \IB method (reference \textit{\href{http://www4.ncsu.edu/~zhilin/TEACHING/MA798Z/Peskin1.pdf}{The immersed boundary method}} \citep{temp} or \textit{\href{http://www.cecs.wright.edu/~haibo.dong/wp-content/themes/publications/IBM_JCP_2007.pdf}{A sharp interface immersed boundary method for compressible viscous flows}} \citep{temp}), the \VOS method (reference \textit{The simulation of fluid-rigid body interaction} \citep{temp}, also described in \textit{Numerical Modeling of Deforming Bubble Transport Related to Cavitating Hydraulic Turbines} \citep{temp}) and the \idxs{rigid fluid}{method}\index{fluid!rigid|see{rigid fluid method}} (reference: \textit{\href{http://www.amath.unc.edu/Faculty/mucha/Reprints/siggraph04.pdf}{Rigid Fluid: Animating the Interplay Between Rigid Bodies and Fluid}} \citep{temp})
%See e.g.: \item \textit{\href{http://physbam.stanford.edu/~fedkiw/papers/stanford2010-04.pdf}{Numerically Stable Fluid-Structure Interactions Between Compressible Flow and Solid Structures}} \item \textit{\href{http://efdl.as.ntu.edu.tw/research/papers/JCP03GCIBM.pdf}{A ghost-cell immersed boundary method for flow in complex geometry}} \item \textit{\href{http://www.cs.columbia.edu/~batty/papers/Batty07.pdf}{A Fast Variational Framework for Accurate Solid-Fluid Coupling}} (solid fraction, non-stick to walls)

\subsubsection{Rotation of rigid bodies}

The \idxs{rotation of a}{rigid body}, in this case the rotation of a \ship that is floating on the surface of the water when it is hit by large waves, depends both on the forces that acts on the \idxs{rigid}{body} as well as well as the  \idxs{moment of}{inertia} of the rigid body.

The dynamics of a rigid body is described by \textit{\href{http://en.wikipedia.org/wiki/Euler\%27s_equations_\%28rigid_body_dynamics\%29}{Euler's equations (rigid body dynamics)}} \citep{temp}.

\section{Desired improvements}

In this \levelname, some improvements that are not required in order to make the method practically useful, but still desired in order to improve the quality of the simulation, are presented.

\subsection{Reduction of spurious reflections in LOD transitions}

When a wave hits a boundary to a region where it propagates with a different speed, or cannot propagate at all, a partial or total reflection of the wave will occur. In natural scenes, this typically happens when the depth of the water changes abruptly from deep water to shallow, or when the wave hits a cliff or similar.

In scenes simulated with a grid of finite size, this usually happens on the border of the grid, unless special care has been taken to this when deciding which \idxsp{boundary}{condition}{s} to use. These reflections are unwanted and referred to as \idxs{spurious}{reflections} since they don't occur in nature.

In scenes simulated on an \octree based \grid, this also happens in \LOD transitions, since different \idxsp{LOD}{level}{s} have different lowest wavelengths they can represent called the \idxs{Nyquist}{frequency} (which is double the cell size for rectangular cells), and the fact that a wavelength which can be represented on two different LOD levels often will propagate with different speeds on the two LOD levels, especially if the wavelength is close to the Nyquist frequency for one of the LOD levels but not close to the Nyquist frequency for the other LOD level.

On scenes simulated on an arbitrary grid though, the reflections corresponding to the reflections that takes place in LOD transitions are often less noticeable as the surface of reflection is less well-defined, which causes the waves to be reflected at multiple locations and become scattered in many directions, although the waves are still eventually totally reflected.

\subsubsection{Perfectly matched layers}

One method for greatly reducing spurious reflections at the border of a structured grid is to use \idxs{perfeclty matched}{layers}. See e.g. \textit{\href{http://liu.diva-portal.org/smash/get/diva2:359805/FULLTEXT01}{Memory Efficient Methods for Eulerian Free Surface Fluid Animation}} \citep{temp}, which explains explicit dampening, implicit dampening, and wave absorbing boundaries --- the perfectly matched layer approach, and evaluates the methods.

\subsubsection{Other absorbing boundary conditions}

Another method that works when the waves have a common speed is to use absorbing boundary conditions (see \citep{temp}). This method works ideally in the \idx{one-dimensional} case if all wavelengths have the same simulated speed, and performs decently well in the \idx{two-dimensional} or \idx{three-dimensional} case. See e.g. \textit{\href{http://www.ce.ncsu.edu/centers/cmg/AWWE/}{the AWWE equations}} \citep{temp}.
\subsection{Wind waves}

In order to obtain a realistic \idxs{sea}{state}\index{state of sea|see{sea state}} in a simulation, it is desirable that the \idxs{water}{surface} \interacts with the \wind in order to give rise to \idxsp{wind}{wave}{s}. In this way, the sea state will be a reflection of the \idxs{wind}{velocity}.

\subsubsection{Spectral methods}

A very cheap and easy way to simulate wind waves is to use a wind dependent \idxs{wave}{spectrum}. A wave spectrum tells how the size of waves with different wavelengths are \distributed, and from that distribution the \idxs{Fourier}{transform} of the free surface elevation can easily be \generated by taking a \random \sample from it. This is then used to \initialize the \idxs{sea}{state} in the simulation.

There are different models for describing the wave spectrum for a certain wind velocity, most of which are \empirical. Some of these spectra take into account the wind direction for increased alignment between the surface and the wind, for example the \idxs{Philips}{spectrum} which is used and tweaked in \textit{\href{http://graphics.ucsd.edu/courses/rendering/2005/jdewall/tessendorf.pdf}{Simulating Ocean Water}} \citep{temp}, or the \idxs{Pierson--Moskowitz}{spectrum}, which was developed in \darkblue{\textit{A Proposed Spectral Form for Fully Developed Wind Seas Based on the Similarity Theory of S.A. Kilaigorodskii}} \citep{temp} in 1964. Another commonly used wave spectrum which builds up over time is the \JONSWAP spectrum\index{spectrum!JONSWAP|see{JONSWAP}} (see \textit{\href{http://www.wikiwaves.org/Ocean-Wave\_Spectra\#JONSWAP\_Spectrum}{JONSWAP Spectrum}}) \citep{temp}.

\subsubsection{Air-water interaction}

Another (somewhat dubious) alternative would be to simulate both the \water and the \air using the \FVM. This method would be slower that using a wave spectrum since it has to simulate more cells, and would probably give a quite poor result since it is difficult to catch the correct interaction between the water and the air for the shortest \wavelengths in the simulation.

\subsection{Improved rendering}

In order to improve the rendering from what is just necessary (which would look almost plastic) to what is actually desired, a realistic \idxs{shading}{model} needs to be implemented.

\subsubsection{Light reflectivity and transmissivity}

When \light hits the \idxs{water}{surface}, not all light is transmitted into the water. Some of the light is reflected, and the amount of light that is reflected depends on the angle of incidence as well as the polarization of the light, according to the \idxs{Fresnel}{equations}.

Normally however, when rendering a \scene with \idxs{computer}{graphics}, one doesn't usually start from the light source when calculating the brightness of an object, but from the observer. On the other hand, according to the \idxs{Helmholtz}{reciprocity principle}\index{principle!Helmholtz reciprocity|see{Helmholtz reciprocity principle}}, one can use the Fresnel equations not only to calculate how much of the light is being reflected, but also the other way around to calculate how much of the light that comes from the surface originally hit the surface from above and was reflected, and how much of it hit the surface from below and was transmitted. In that way it is possible to account also for the light that has been reflected under the water, which has been filtered by the objects it has been reflected on under the surface of the water.

\subsubsection{Illumination model for water surfaces}

Typically, when rendering an \idxs{ocean}{scene}, not the entire wave spectrum is used but only the lowest frequencies of it, since too high frequencies will give rise to \folding which may in turn give rise to unwanted effects such as \idxsp{Moire}{pattern}{s}. Besides, because of the limited resolution of the \grid, short \wavelengths will automatically be removed even if the rendering would allow shorter wavelengths. Therefore, not all frequencies will be used in the \idxs{rendered}{image}. If much of the \idxs{wave}{energy} in a \idxs{sea}{state} lies in the part of the \idxs{wave}{spectrum} that will not be used when rendering the image, such as when the surface is viewed from a far distance, this can become very evident.

Since the \idxs{surface}{normal} of the water surface depends on the \gradient of the \idxs{free surface}{elevation}, all surface waves will help to build up a variance in the surface normal. If viewed from a distance that is just large enough, the surface waves themselves will be too small to be visible, but the variance of the normal that is created by the surface waves will be visible since it will give rise to a blur in \reflections in the surface. This is for example what often causes the reflection of the \sun in the sea to look like a long vertical stripe under the sun instead of something that looks like a sun. So if certain wavelengths are removed from the water surface, they should be accounted for by blurring out the image that is reflected in the water, of course in the correct way, or the rendered water will look too \smooth.

A derivation of an illumination model for sea surfaces is found in \appref{chap:illumination_model_derivation}.

\subsection{Visual effects}

\subsubsection{Choppy waves}

Waves of a single frequency is not a perfect \sinusoidal, but a \trochoid, which makes the curvature greater at the \idxs{wave}{crest} and lesser at the \idxs{wave}{valley}, which makes the waves look more \idxse{choppy}{waves}{choppy}. By letting sinusoidals displace the water surface, not only vertically, but also horizontally, trochoids can effectively be created and a more realistic look of the water surface is obtained. These waves are called \idxsp{Gerstner}{wave}{s} and were first found as an approximate solution to the fluid dynamic equations almost 200 years ago, as noted in \textit{\href{http://graphics.ucsd.edu/courses/rendering/2005/jdewall/tessendorf.pdf}{Simulating Ocean Water}}) \citep{temp}, and is today used extensively used in computer graphics for animating water surfaces. What is claimed to be an implementation of Gerstner waves can be seen in \citep{ceribral2012}.

\subsubsection{Splash and foam}

In rough weather conditions, the waves will become higher and choppier, and their crests will break more easily, forming white foam where they break, as can be seen in \figref{fig:sea_storm}, which is known as oceanic whitecaps, or just whitecaps. When high waves hit the side of a ship, they will also shatter and form a spray of small particles in the air, usually just referred to as splashes.

In \textit{\href{http://cg.informatik.uni-freiburg.de/publications/2012_CGI_sprayFoamBubbles.pdf}{Unified Spray, Foam and Bubbles for Particle-Based Fluids}} \citep{temp}, "diffuse particles" are generated based on the water's potential to trap air, its likelihood to be at the crest of a wave and its kinetic energy. In \textit{\href{http://nguyendangbinh.org/Proceedings/Eurographics/2003/cgf/volume22/issue3/paper127/paper127.pdf}{Realistic Animation of Fluid with Splash and Foam}} \citep{temp}, water is turned into "splash particles" where the curvature of the water exceeds a certain \threshold. The results of the use of diffuse/splash particles can bee seen in videos such as and \citep{RealFlowLabs2011,Chandel2009}.

In turn, \textit{\href{http://nguyendangbinh.org/Proceedings/Eurographics/2003/cgf/volume22/issue3/paper127/paper127.pdf}{Realistic Animation of Fluid with Splash and Foam}} \citep{temp} concludes that there seems to be "few papers on handling of effects of splashes and foam with fluid", even though it mentions the paper \textit{\href{https://subversion.assembla.com/svn/gpuocean/trunk/docs/rendering-natural-waters-00.pdf}{Rendering Natural Waters}} \citep{temp} as one of them, which it claims "makes crude approximations". However, this paper includes an empirical formula for the "fractional area of the wind-blown water surface that is covered by foam" $f$ (the time-averaged area of the foam/the total area of the water surface) that looks like

\begin{equation} \label{eq:fractional_area_naiive}
f = 1.59 \times 10^{-5}U^{2.55}\exp[0.0861(T_w - T_a)],
\end{equation}

where $U$ is the wind speed, $T_w$ is the water temperature and $T_a$ is the air temperature (this equation is in turn claimed to have been taken from the book \textit{\href{http://books.google.se/books?id=xuwFz1bPTHgC}{Oceanic Whitecaps: Their Role in Air-Sea Exchange Processes}} by E. C. Monahan and G. MacNiocaill \citep{temp}). This kind of information has been obtained by doing \idxsp{satellite}{measurement}{s}. However, according to the \idxs{Beaufort}{scale}, crests don't begin to break until there is at least a gentle breeze, which starts at about \mbox{3.4 m/s}, while according to \eqref{eq:fractional_area_naiive}, there would always be some whitecaps area. As a remedy, one could subtract a small value ${f_0 = f(U=U_0,\, T_w-T_a=\Delta T_0)}$ (where, tentatively, ${U_0 = 3.4\text{ m/s}}$ and ${\Delta T_0 = 0}$) and create a corrected estimate $f^*$ of the fractional area, defined as

\begin{equation}
f^* = max(f-f_0,\,0).
\end{equation}

Furthermore, tt suggests that "as a crude approximation to the true distribution, one can put whitecaps at positions on the surface where the amplitude of the waves is the largest". However, if following this method, the water surface would preferably first be high-pass filtered before determining on which parts of the surface the free surface elevation is the largest, to prevent that some (large) regions of the surface that would happen to be a bit higher elevated than other regions would get much more whitecaps area.

In \textit{\href{http://web1.see.asso.fr/ocoss2010/Session_4/20100531111216_Monnier_OCOSS2010-Paper_MERCUDA_item_2.pdf}{Real time modelling of multispectral ocean scenes}} \citep{temp}, it is on the other hand the vertical downward acceleration that is used to determine where to put the whitecaps, instead of the free surface elevation. The \threshold for the acceleration is calculated dynamically to keep the total whitecaps area at the correct level. 

As it turns out, the larger the Lagrangian vertical downward acceleration is, the smaller the pressure gradient is. Without a pressure gradient, there will be nothing that keeps the water and the air separated, and the two fluids are much more prone to mix. So where the downward acceleration is large, the pressure gradient will be small, and water and air will naturally be more prone to mix, especially under large wind speeds where the \idxs{velocity}{shear} at the surface is large, which increases the chance of getting \idxs{Kelvin–Helmholtz}{instability} in the system.

Additionally to using a \threshold for some specific property of the surface to determine where the whitecaps are located, some methods also use a \idx{half-life} for the whitecaps that have past to the other side of the \threshold to model a more realistic destruction process for the whitecaps, as for example can be seen in \citep{ozernik2009,cebasVT2010}.

